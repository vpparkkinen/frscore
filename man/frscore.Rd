\name{frscore}
\alias{frscore}
\title{frscore}
\usage{
frscore(
  sols,
  scoretype = c("full", "supermodel", "submodel"),
  normalize = c("truemax", "idealmax", "none"),
  maxsols = 50,
  verbose = FALSE,
  print.all = FALSE
)
}
\arguments{
\item{sols}{Character vector of class "stdAtomic" or "stdComplex" (as generated by \code{\link[cna:cna]{cna()}}) that contains the solutions/models to be scored.}

\item{scoretype}{Character vector specifying the scoring method: \code{"full"}
(default; scoring is based on counting both sub- and supermodels), \code{"supermodel"}
(count supermodels only), \code{"submodel"} (count submodels only).}

\item{normalize}{Character vector that determines the method used in
normalizing the scores. \code{"truemax"} (default) normalizes by the highest score among the elements of \code{sols},
such that the highest scoring solution types get score 1. \code{"idealmax"}
normalizes by a theoretical maximum score (see Details). }

\item{maxsols}{Integer determining the maximum number of unique solution
types found in \code{sols} to be included in the scoring (see Details).}

\item{verbose}{Logical; if \code{TRUE}, additional
information about submodel relations among the unique solution types found
in \code{sols} is printed. Defaults to \code{FALSE}.}

\item{print.all}{Logical, controls the number of entries printed when
printing the results. If \code{TRUE}, results are printed as when using the defaults of
\code{print.data.frame}. If \code{FALSE}, 20 highest scoring
solutions/models are printed.}
}
\value{
A named list where the first element is a data frame containing
the unique solution/model types and their scores. Rest of the elements
contain additional information about the submodel relations among
the unique solutions types and about how
the function was called.
}
\description{
Calculate fit-robustness scores for a set of \code{cna}
solutions/models
}
\details{
\code{frscore()} implements fit-robustness scoring as introduced in Parkkinen and Baumgartner (2021). The function calculates the
fit-robustness scores of Boolean solutions/models output by the \code{\link[cna:cna]{cna()}} function of the \pkg{cna} package. The solutions are given to \code{frscore()} as a character vector \code{sols} obtained by reanalyzing
a data set repeatedly, e.g. with \code{rean_cna()}, using different consistency and coverage
thresholds in each analysis.

When the argument \code{scoretype} is set to its default value \code{"full"}, the score of each \code{sols[i]} is calculated by counting both the sub- and supermodel relations \code{sols[i]} has to the other elements of \code{sols}. Setting \code{scoretype} to \code{"supermodel"} or \code{"submodel"} forces the scoring to be based on, respectively, supermodel and submodel relations only. In the former setting, less complex models will tend to get higher fit-robustness scores because they tend to have more supermodels in \code{sols}, while the latter setting gives preference to more complex models, which have more submodels in \code{sols} on average.

The fit-robustness scores can be normalized in two ways. In the default setting \code{normalize = "truemax"}, the score of each \code{sols[i]} is divided by the maximum score obtained by an element of \code{sols}. In case of \code{normalize = "idealmax"}, the score is normalized not by an actually obtained maximum but by an idealized maximum, which is calculated by assuming that all solutions of equal complexity in \code{sols} are identical and that for every \code{sols[i]} of a given complexity, all less complex elements of \code{sols} are its
submodels and all more complex elements of \code{sols} are its supermodels.
When normalization is applied, the normalized score is shown in its
own column 'norm.score' in the results. The raw scores are shown in the column
'score'.

If the size of the consistency and coverage interval scanned in the reanalysis series generating \code{sols} is large or there are many model ambiguities, \code{sols} may contain so many different types of solutions/models that robustness cannot be calculated for all of them in reasonable time. In that case, the argument \code{maxsols} allows for capping the number of solution types to be included in the scoring (defaults to 50). \code{frscore()} then selects the most frequent solutions/models in \code{sols} of each complexity level until  \code{maxsols} is reached and only scores the thus selected elements of \code{sols}.

If the argument \code{verbose} is set to \code{TRUE}, \code{frscore()} also prints a list indicating for each \code{sols[i]} how many raw score points it receives from which elements of \code{sols}. The verbose list is ordered with decreasing fit robustness scores.

}
\references{
V.P. Parkkinen and M. Baumgartner (2021), \dQuote{Robustness and Model Selection in Configurational Causal Modeling,} \emph{Sociological Methods and Research}, doi:10.1177/0049124120986200.

Basurto, Xavier. 2013. \dQuote{Linking Multi-Level Governance to Local Common-Pool
Resource Theory using Fuzzy-Set Qualitative Comparative Analysis: Insights from
Twenty Years of Biodiversity Conservation in Costa Rica.} \emph{Global Environmental Change} \strong{23} (3):573-87.

}
\seealso{\code{\link{rean_cna}}, \code{\link[cna:cna]{cna}}}
\examples{
# Artificial data from Parkkinen and Baumgartner (2021)
sols1 <- rean_cna(d.error, attempt = seq(1, 0.8, -0.1))
sols1 <- do.call(rbind, sols1)
frscore(sols1$condition)

# Real fuzzy-set data from Basurto (2013)
\donttest{
sols2 <- rean_cna(d.autonomy, type="fs", ordering = list("EM", "SP"),
         strict = TRUE, maxstep = c(3,3,9))
sols2 <- do.call(rbind, sols2)$condition  # there are 217 solutions
# At the default maxsols only 50 of those solutions are scored.
frscore(sols2)
# By increasing maxsols the number of solutions to be scored can be controlled.
frscore(sols2, maxsols = 100)

# Changing the normalization
frscore(sols2, normalize = "none")
frscore(sols2, normalize = "truemax")
frscore(sols2, normalize = "idealmax")

# Changing the scoring
frscore(sols2, scoretype = "supermodel")
frscore(sols2, scoretype = "submodel")

frscore(sols2, maxsols = 20, verbose = TRUE)
}

}
