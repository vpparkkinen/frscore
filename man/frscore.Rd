\name{frscore}
\alias{frscore}
\title{frscore}
\usage{
frscore(
  sols,
  dat = NULL,
  scoretype = c("full", "supermodel", "submodel"),
  normalize = c("truemax", "idealmax", "none"),
  maxsols = 50,
  verbose = FALSE,
  print.all = FALSE
)
}
\arguments{
\item{sols}{Character vector of class "stdAtomic" or "stdComplex" (as generated by \code{\link[cna:cna]{cna()}}) that contains the solutions/models to be scored.}

\item{dat}{A \code{configTable}, a data frame, a matrix, or a list that specifies the range of admissible factor values
for the factors featured in the models included in \code{sols}. Only needed when the models in
\code{sols} are multi-valued, otherwise ignored.}

\item{scoretype}{Allowed for backward compatibility only, due to be dropped
in next version. Character vector specifying the scoring method: \code{"full"}
(default; scoring is based on counting every compatibility relation found), \code{"supermodel"}
(count compatibility with more complex models only), \code{"submodel"} (count
compatibility with less complex models only).}

\item{normalize}{Character vector that determines the method used in
normalizing the scores. \code{"truemax"} (default) normalizes by the highest score among the elements of \code{sols},
such that the highest scoring solution types get score 1. \code{"idealmax"}
normalizes by a theoretical maximum score (see Details). }

\item{maxsols}{Integer determining the maximum number of unique solution
types found in \code{sols} to be included in the scoring (see Details).}

\item{verbose}{Logical; if \code{TRUE}, additional
information about causal compatibility relations among the unique solution types found
in \code{sols} is printed. Defaults to \code{FALSE}.}

\item{print.all}{Logical, controls the number of entries printed when
printing the results. If \code{TRUE}, results are printed as when using the defaults of
\code{print.data.frame}. If \code{FALSE}, 20 highest scoring
solutions/models are printed.}
}
\value{
A named list where the first element is a data frame containing
the unique solution/model types and their scores. Rest of the elements
contain additional information about the submodel relations among
the unique solutions types and about how
the function was called.
}
\description{
Calculate fit-robustness scores for a set of \code{cna}
solutions/models
}
\details{
\code{frscore()} implements fit-robustness scoring as introduced in Parkkinen and Baumgartner (2021). The function calculates the
fit-robustness scores of Boolean solutions/models output by the \code{\link[cna:cna]{cna()}} function of the \pkg{cna} package. The solutions are given to \code{frscore()} as a character vector \code{sols} obtained by reanalyzing
a data set repeatedly, e.g. with \code{rean_cna()}, using different consistency and coverage
thresholds in each analysis.

Fit-robustness is calculated by determining which models in \code{sols} are
compatible with each other in the causal attributions they make. For multi-valued
models, this requires that the range of admissible values for the factors featured
in the models is known. This information is provided via the argument \code{dat},
that accepts data frames, \code{configTable}s, and lists of factor-value ranges as its value,
in the same manner as \code{\link[cna:full.ct]{cna::full.ct()}}.
Typically, one would use the data set that the models in \code{sols}
were inferred from as the value of \code{dat}, and this is what is done when
\code{frscore} is called within \code{frscored_cna}. When the models in \code{sols}
are binary/crisp-set, \code{dat} should be left to its default value \code{NULL},
and will in any case be ignored.

The argument \code{scoretype} is deprecated as of \code{frscore} v0.3.0, and will be dropped
from future versions of the package.
Explicitly setting its value
is allowed so that older code can be run without errors, but doing this is discouraged.
In \code{frscore} v0.3.0, the permissible values of \code{scoretype} have the following effects.
When set to its default value \code{"full"}, the score of each solution/model \strong{m} in \strong{M} is calculated by counting
the number of other elements of \strong{M} that are compatible with \strong{m}
in the causal attributions that they make. Setting \code{scoretype} to \code{"supermodel"} or \code{"submodel"} forces the scoring to be based on, respectively, counting compatibility relations with more complex, and less complex models only.
In the former setting, less complex models will tend to get higher fit-robustness scores, while the latter setting gives preference to more complex models. In future versions of \code{frscore}, fit-robustness
scores will be calculated as with the current default value (\code{"full"}), and
changing the scoring method will not be possible.

The fit-robustness scores can be normalized in two ways. In the default setting \code{normalize = "truemax"}, the score of each \code{sols[i]} is divided by the maximum score obtained by an element of \code{sols}. In case of \code{normalize = "idealmax"}, the score is normalized not by an actually obtained maximum but by an idealized maximum, which is calculated by assuming that all the models in \code{sols} are causally compatible with each other.
Different values of \code{scoretype} will result in different values of this theoretical
maximum score, insofar as the models in \code{sols} vary in their complexity.
When normalization is applied, the normalized score is shown in its
own column 'norm.score' in the results. The raw scores are shown in the column
'score'.

If the size of the consistency and coverage interval scanned in the reanalysis series generating \code{sols} is large or there are many model ambiguities, \code{sols} may contain so many different types of solutions/models that robustness cannot be calculated for all of them in reasonable time. In that case, the argument \code{maxsols} allows for capping the number of solution types to be included in the scoring (defaults to 50). \code{frscore()} then selects the most frequent solutions/models in \code{sols} of each complexity level until  \code{maxsols} is reached and only scores the thus selected elements of \code{sols}.

If the argument \code{verbose} is set to \code{TRUE}, \code{frscore()} also prints a list indicating for each \code{sols[i]} how many raw score points it receives from which elements of \code{sols}. The verbose list is ordered with decreasing fit robustness scores.

}
\references{
V.P. Parkkinen and M. Baumgartner (2021), \dQuote{Robustness and Model Selection in Configurational Causal Modeling,} \emph{Sociological Methods and Research}, doi:10.1177/0049124120986200.

Basurto, Xavier. 2013. \dQuote{Linking Multi-Level Governance to Local Common-Pool
Resource Theory using Fuzzy-Set Qualitative Comparative Analysis: Insights from
Twenty Years of Biodiversity Conservation in Costa Rica.} \emph{Global Environmental Change} \strong{23} (3):573-87.

}
\seealso{\code{\link{rean_cna}}, \code{\link[cna:cna]{cna}}}
\examples{
# Artificial data from Parkkinen and Baumgartner (2021)
sols1 <- rean_cna(d.error, attempt = seq(1, 0.8, -0.1))
sols1 <- do.call(rbind, sols1)
frscore(sols1$condition)


# Real fuzzy-set data from Basurto (2013)
\donttest{
sols2 <- rean_cna(d.autonomy, type="fs", ordering = list("EM", "SP"),
         strict = TRUE, maxstep = c(3,3,9))
sols2 <- do.call(rbind, sols2)$condition  # there are 217 solutions
# At the default maxsols only 50 of those solutions are scored.
frscore(sols2)
# By increasing maxsols the number of solutions to be scored can be controlled.
frscore(sols2, maxsols = 100)

# Changing the normalization
frscore(sols2, normalize = "none")
frscore(sols2, normalize = "truemax")
frscore(sols2, normalize = "idealmax")


# verbose
frscore(sols2, maxsols = 20, verbose = TRUE)
}

# Multi-valued data/models (data from Hartmann and Kemmerzell (2010))
sols3 <- rean_cna(d.pban, outcome = "PB=1", type = "mv")
sols3 <- do.call(rbind, sols3)$condition
# frscore() needs the data to determine admissible factor values
frscore(sols3, dat = d.pban)

}
