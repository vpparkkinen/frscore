% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/is_compatible.R
\name{is_compatible}
\alias{is_compatible}
\title{Determine the causal compatibility of \code{cna} models}
\usage{
is_compatible(x, y, dat = NULL)
}
\arguments{
\item{x}{A string that specifies a valid \code{cna} model.}

\item{y}{A string that specifies a valid \code{cna} model.}

\item{dat}{A \code{configTable}, a data frame, a matrix, or a list that
specifies the range of admissible factor values for the factors featured in
\code{x} and \code{y}. Only needed when the models \code{x} and \code{y}
are multi-valued, otherwise ignored.}
}
\description{
Determine whether the causal ascriptions made by
\emph{candidate} solution/model \code{x} are compatible with the causal
ascriptions made by \emph{target} model \code{y}.
}
\details{
\code{is_compatible()} checks whether the causal relevance claims
made by the candidate model \code{x} are compatible with the causal
structure represented by the target model \code{y}. In short, the function
checks whether \code{x} is causally compatible with \code{y}. When \code{x}
and \code{y} are multi-valued models, a further argument \code{dat} must be
provided to determine the admissible factor values for the factors featured
in \code{x} and \code{y}. This would typically be the data set that
\code{x} and \code{y} were inferred from.

For \code{x} to be causally compatible with \code{y}, (1), every ascription
of direct causal relevance made by \code{x} must have a counterpart direct
causal ascription in \code{y}, or a counterpart indirect causal ascription
in \code{y} such that any factors that mediate the relation in \code{y} (making
it indirect in \code{y}) are omitted in \code{x}. (2), every ascription of indirect
causal relevance made by \code{x} must have a counterpart indirect causal
ascription in \code{y}. That is, every pair of factors represented as
direct cause and effect in \code{x} must either be represented as direct
cause and effect in \code{y}, or must correspond to a transitive chain of
direct causal relations according to \code{y} such that \code{x} omits the
factors that mediate the relation in \code{y}. Direct causal relations are those
causal relations that can be read off from the explicit syntax of an atomic
solution/model ("asf"), and is thus relativized to the set of factors
included into a model. For example, according to \code{"A*F+B<->C"},
\code{A} and \code{B} are direct causes of \code{C} on alternative paths.
Furthermore, candidate model \code{"A+B<->C"} is causally compatible with
the target \code{"A*F+B<->C"}, but \code{"A+B*U<->C"} is not, since the
latter makes a claim about the causal relevance of \code{U} to \code{C}
which is not made by the target. Each direct cause is a difference-maker
for its effect in some circumstances where alternative sufficient causes of
the effect are not present, and the \emph{co-factors} located on the same
path are present. For example, \code{"A*F+B<->C"} claims that when \code{B}
is absent and \code{F} is present, difference in the presence of \code{A}
will associate with differences in \code{C}, given some suitable
configuration of factors not explicitly represented in \code{"A*F+B<->C"}.
When \code{x} and \code{y} are atomic, i.e. represent direct causal
relations only, a necessary and sufficient condition for causal
compatibility is that \code{x} is a \link[cna:is.submodel]{submodel} of
\code{y}.

A causal chain comprises sequentially ordered direct causal relations. For
example, \code{"(A+B<->C)*(C+D<->E)"} represents a \emph{transitive} causal
chain where \code{A} and \code{B} are indirectly causally relevant for
\code{E} in virtue of being causes \code{E}'s more proximate cause \code{C}
and the difference-making ability they have on \code{E} via \code{C}. A
model like \code{"A+B<->E"} is causally compatible with
\code{"(A+B<->C)*(C+D<->E)"} even though they make different claims about
direct vs. indirect causal relevance. Direct causation is a model-relative
notion, so this difference in itself does not entail incompatibility, given
that the simpler model does not include the mediating factor \code{C} at all.
Both models entail that \code{A} and \code{B} are difference-makers for
\code{E} in some circumstances, and hence causally relevant for \code{E}.
The models are thus compatible;
the simpler one merely omits the middle link \code{C} which transmits the
causal influence of \code{A} and \code{B} to \code{E}. Hence, both models
can be seen as descriptions of the same causal structure, one more complete
in detail than the other.

An \emph{in}transitive chain is a causal chain where the influence of some
upstream causes is not transmitted to some downstream effects. For example,
\code{"(A+B<->C)*(C*a+D<->E)"} represents a chain where \code{A} is not
causally relevant to \code{E} despite being a cause of one of \code{E}'s
direct causes (\code{C}). That is, according to this model, \code{A} is not
a difference-maker for \code{E}, and \code{"A+B<->E"}, which makes this
claim, is not causally compatible with it.

Besides avoiding causal relevance ascriptions that are not present in the
target at all, the candidate should also attribute causal relevance
correctly in the sense of ordering the represented causes in a way that is
compatible with the target. Factors that appear as direct causes of the
same outcome both in the target and the candidate should be grouped into
alternative disjuncts similarly in both. Analogously, causes that appear on
different levels or steps in a causal chain according to the target should
not be represented as same-level causes by the candidate. Say, for example,
that the target is \code{"(A+B<->C)*(C+D<->E)*(E+F<->G)"}. Candidate models
\code{"(A+B<->G)"} and \code{"(A+B<->E)*(E+F<->G)"} are both compatible
with this target. By contrast, neither of \code{"(A+C<->G)"} and
\code{"(A+B<->C)*(C+E<->G)"} is compatible with the target. Both of the
latter two models commit the error of representing as same-level causes
factors that the target represents as cause and effect. For example,
\code{"(A+C<->G)"} claims that \code{A} and \code{C} are same-level causes
of \code{G}, whereas the target says \code{A} is a cause of \code{C}. That
this is a conflict in causal relevance ascription is easiest to see by
considering the implications for difference-making: \code{"(A+C<->G)"}
claims that differences in \code{A} associate with differences in \code{G}
when \code{C} is fixed absent, but the target claims that this is
impossible.

Finally, causal compatibility requires that any claims of indirect causal
relevance made by a candidate model are claims made by the target also.
Consider the target model \code{"(A+B*D<->C)*(C+D<->G)"} and a candidate
\code{"(A+B*D<->C)*(C<->G)"}. Despite superficial similarity (the candidate
is a submodel of the target), the candidate is incompatible with the
target. Namely, the candidate makes a claim that \code{B} is indirectly
causally relevant for \code{G}, a claim that is not made by the target.
Again, it is best to examine the specific difference-making claim in
question. The candidate model claims that differences in \code{B} when
\code{D} is fixed to be present make a difference to the presence of
\code{G}. But this is false according to the target. The target claims that
\code{G} is always present whenever \code{D} is: \code{B} is not causally
relevant for \code{G} despite being a cause of an intermediary factor
\code{C}.

In its implementation, \code{is_compatible} exploits the fact that a
submodel relation is a necessary and sufficient condition for causal
compatibility of two atomic models. First, the function checks if the
component asfs of the candidate are submodels of the target \emph{as is}.
If yes for all, each of the candidate's direct causal relevance ascriptions
has a counterpart direct causal relation in the target, and the function
proceeds to the second phase. For those direct relations that cannot be
mapped to direct relations as represented by the target, the function
searches for counterpart indirect relations in the target. Since \code{cna}
models do not represent indirect relations explicitly, these must be
explicated by syntactically manipulating the target. This involves finding
asfs in the target with the same outcomes as those candidate asfs that are
not submodels of the target \emph{as is}. For each such component asf of
the target, factors in the disjunction on the left hand side of the
equivalence sign ("<->") are substituted with the disjunctions, if any,
that according to the target represent their causes. The resulting
expression is then minimized to render it causally interpretable. What is
left is an atomic model representing some of the target's indirect causal
claims as direct causal claims. Then, the candidate asfs that are not
submodels of the target \emph{as is} are tested against the manipulated
target asfs for submodel relation. This process is repeated until all the
submodel checks return TRUE, or no further substitutions are possible. In
the former case, the function proceeds to the second phase. In the latter
case, the candidate is deemed not causally compatible with the target, and
the function returns FALSE.

An example is in order to illustrate the procedure so far. Say that the
target and candidate are \code{"(A+B<->C)*(C+D<->E)"} and \code{"A+B<->E"},
respectively. Since the only candidate asf is not a submodel of the target,
one then attempts to find indirect causal relevance claims in the target to
license the direct causal claims made by that asf. By the procedure
described above, one focuses on the second asf of the target,
\code{"C+D<->E"}, and seeks to syntactically manipulate that until it is
transformed into a supermodel of \code{"A+B<->E"}, or until no
transformation is possible. According to the first component asf of the
target, \code{C} is equivalent to (caused by) \code{A+B}. Hence, \code{C}
in \code{"C+D<->E"} can be replaced with \code{A+B}, which yields
\code{"(A+B)+D<->E"}, reducing simply to \code{"A+B+D<->E"}. Since
\code{"A+B<->E"} is a submodel of \code{"A+B+D<->E"}, we have shown that
the target makes claims of indirect causal relevance that license the
(direct) causal claims made by the candidate.

The purpose of the second phase is to check that all indirect causal claims
made by the \emph{candidate} model have a counterpart in the target. This
involves doing all the substitutions of left-hand side factors by their
causes in the candidate model, to generate expressions that explicitly
represent the indirect claims of the candidate. The asfs generated by such
manipulations of the candidate model are then checked against the target
similarly to the first phase. For example, say that
\code{"(A+B*D<->C)*(C+D<->G)"} and \code{"(A+B*D<->C)*(C<->G)"} are the
target and the candidate, respectively. Here, each candidate asf
\code{"A+B*D<->C"} and \code{"C<->G"} has a supermodel in one of the target
asfs \code{"A+B*D<->C"} and \code{"C+D<->G"}, so the function proceeds to
the second phase. In the second phase, the indirect causal claims of the
candidate are first made explicit. By substituting \code{"A+B*D"} in place
of \code{C} in the second asf of the candidate and minimizing, one gets
\code{"A+B*D<->G"}, which represents the indirect causal relevance, as
claimed by the candidate, of \code{"A+B*D"} on \code{G}. This expression is
then tested against the target as in the first phase: the target asf with
\code{G} as the outcome is manipulated to reflect the indirect claims that
the target makes about \code{G}. After substitution and minimization, we
get \code{"A+D<->G"}, meaning that the target does \emph{not} make a claim
of indirect causal relevance of \code{B} for \code{G}. That the candidate
and the target are incompatible in their indirect causal claims is shown by
the fact that \code{"A+B*D<->G"} is not a submodel of \code{"A+D<->G"}, and
the function returns FALSE.

Due to the computational demands of some of the steps in the above
procedure, \code{is_compatible} is an approximation, rather than strictly
valid check for causal compatibility of \code{cna} models. Since the
syntactic manipulations and, especially, minimization of the resulting
expressions is so costly, \code{is_compatible} relies on the
\code{\link[cna:rreduce]{rreduce()}} function from the \link[cna:cna-package]{cna}
package for minimization. \code{\link[cna:rreduce]{rreduce()}} randomly chooses a
single reduction path to produce only one minimal form of an expression
whenever more than one exists, i.e. when the expression is ambiguous in its
causal claims. In the case of ambiguous models, the output of
\code{is_compatible} may depend on which reduction path(s) were chosen.
These cases are rare enough to not significantly affect the intended use of
\code{is_compatible} in the context of \code{frscore}. Another instance of
\code{is_compatible} taking a shortcut is when processing cyclic models
like \code{"(A+B<->C)*(C+D<->A)"}. Here the problems are as much
philosophical as computational. It is clear that a cyclic candidate model
cannot be compatible with a non-cyclic target. However, problems arise when
trying to determine if a non-cyclic candidate is compatible with a cyclic
target: it is not clear what counts as an incompatibility in causal
ordering, given that a cyclic target model does not (causally) order its
factors strictly, but a non-cyclic candidate does. Since many conclusions
can be argued for here but some approach must be taken to ensure that
\code{is_compatible()} works on all valid \code{cna} models,
\code{is_compatible()} takes the least costly option and simply checks
whether the candidate is a submodel of the target, and returns the result.
}
