## frscored_cna() performs a reanalysis series on a data set with all combinations of 
## fit threshold values that can be generated by varying consistency and coverage in a given range 
## by a constant value, determined respectively by arguments 'fit.range' and 'granularity',
## and calculates fr-scores for the models returned in the analyses.
## If a candidate model is provided as 'test.model', result for that model will be printed separately
## (assuming one uses print.frscored_cna()), provided the model is found in the reanalysis series, if not,
## the function stops.

#' @import cna
#' @export
frscored_cna <- function(x, 
                         fit.range = c(1, 0.7), 
                         granularity = 0.1, 
                         output = c("csf", "asf"),
                         scoretype = c("full", "supermodel", "submodel"),
                         normalize = c("truemax", "idealmax", "none"), 
                         verbose = FALSE,
                         test.model = NULL,
                         print.all = FALSE,
                         maxsols = 50,
                         ...){
  cl <- match.call()
  dots <- list(...)
  if (any(c("cov", "con", "con.msc") %in% names(dots))){
    stop("cna arguments 'con', 'cov', 'con.msc' not meaningful")
  }
  cl$fit.range <- cl$granularity <- cl$normalize <- 
    cl$verbose <- cl$scoretype <- 
    cl$test.model <- cl$print.all <-  
    cl$scoretype <- cl$maxsols <- NULL
  cl[[1]] <- as.name("rean_cna")
  attempt <- seq(max(fit.range), min(fit.range), -granularity)
  cl$attempt <- attempt
  cl$output <- match.arg(output)
  clres <- eval.parent(cl)
  rescomb <- do.call(rbind, clres)
  rescomb <- rescomb[!is.na(rescomb[,1]),] 
  rescombtemp <- rescomb
  rescomb <- rescomb[,-c(which(names(rescomb) %in% c("cnacon", "cnacov")))]
  rescomb$condition <- as.character(rescomb$condition)
  rescomb$condition <- gsub("\\),\\(", "\\)*\\(", as.character(rescomb$condition))
  scoretype <- match.arg(scoretype)
  normalize <- match.arg(normalize)
  if (is.null(test.model)){
    scored <- frscore(rescomb$condition, normalize = normalize,
                      verbose = verbose, scoretype = scoretype,
                      maxsols = maxsols)
    if(is.null(scored)){warning('no solutions found in reanalysis series, perhaps consider lower fit range \n \n')
      return(NULL)}
  } else {
    if(any(sapply(rescomb$condition, function(x) identical.model(x, test.model)))){
      scored <- frscore(rescomb$condition, normalize = normalize, 
                        verbose = verbose, scoretype = scoretype,
                        maxsols = maxsols)
      if(is.null(scored)){warning('no solutions found in reanalysis series, perhaps consider lower fit range \n \n')
        return(NULL)}
    } else {
      stop('test.model not found in reanalysis series')
    }
  }
  
  sc <- scored[[1]]
  names(sc)[names(sc) == "model"] <- "condition"
  rescombXscored <- dplyr::left_join(rescomb, sc, by="condition") %>% 
    filter(!is.na(score))
  
  rescombXscored <- unique(rescombXscored)
  rescombXscored <- rescombXscored[order(rescombXscored$complexity, decreasing = T),]
  rescombXscored <- rescombXscored[order(rescombXscored$score, decreasing = T),]
  rownames(rescombXscored) <- 1:nrow(rescombXscored)
  
  if(!is.null(test.model)){
    tested <- rescombXscored[sapply(rescombXscored$condition, function(x) identical.model(x, test.model)),]
  } else {
    tested <- test.model
  }
  
  out <- structure(list(rean_models = rescombXscored, 
                        tested = tested, 
                        verbose = scored$verbose, 
                        print.all = print.all,
                        fit.range = fit.range,
                        granularity = granularity,
                        scoretype = scoretype,
                        normal = normalize,
                        rean.results = rescombtemp,
                        maxsols = scored$maxsols), 
                   class = c("frscored_cna", "list"))
  return(out)
}

# Print method for frscored_cna()

print.frscored_cna <- function(x, verbose = x$verbose, print.all = x$print.all, maxsols = x$maxsols){
  cat('FR-scored reanalysis series with fit range', x$fit.range[1], 'to', x$fit.range[2], 'with granularity', x$granularity, '\n')
  cat('Score type:', x$scoretype, '||', 'score normalization:', x$normal, '\n')
  if(maxsols$maxsols == "ignored"){
    cat("no submodel checks were needed, argument 'maxsols' ignored \n")
  } else {
    cat("maxsols set to", maxsols$maxsols, "--", maxsols$excluded, "solution types excluded from scoring \n\n")
  }
  cat('----- \n \n')
  if(!is.null(x$tested)){
    cat('Candidate model tested:', x$tested$condition, '\n \n')
    print(x$tested)
    cat('\n \n')
  }
  cat('Model types: \n \n')
  nr <- nrow(x$rean_models) - 20L
  if (print.all){
    print(x$rean_models)
  } else {
    print(head(x$rean_models, n = 20L))
    cat('\n')
    if(nr > 0){
      cat('...there were', nr, 'more scored model types, use \'print.all = TRUE\' to print all \n')
    }  
  }
  if(!is.null(verbose)){
    cat('\n')
    cat('Score composition: \n')
    cat('----- \n')
    
    print(verbose)
  }
  invisible(x)
}
